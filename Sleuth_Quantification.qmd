---
title: "Sleuth and Kallisto"
author: "Roberto Álvarez"
format: revealjs
editor: visual
#format:
 # html:
  #  toc: true
   # toc_float: true
  #pdf: default
  #docx: default
---


##  Sleuth from Kallisto

Este tutorial te guiará a través de un análisis  de RNA-Seq utilizando [kallisto](https://pachterlab.github.io/kallisto/about), usando Sleuth. Este tutorial se basa en uno del laboratorio [Pachter lab](https://pachterlab.github.io/sleuth_walkthroughs/boj/analysis.html) y lo pueden encontrar [aquí](https://cyverse-kallisto-tutorial.readthedocs-hosted.com/en/latest/index.html)

## Paso 1: Cargar Sleuth y bibliotecas adicionales



```{r}
#| echo: true
library(sleuth)
library("gridExtra")
library("cowplot")
```


## BiomaRt


También utilizaremos las herramientas de [biomaRt](https://bioconductor.org/packages/release/bioc/html/biomaRt.html), que nos permitirán obtener nombres de genes reconocibles desde una base de datos.


```{r echo=FALSE, message=FALSE, warning=FALSE}
#| echo: true
library("biomaRt")
```



## Paso 2:  Cargar los datos

### Localizar nombres de muestras y describir nuestro diseño experimental

Necesitamos proporcionar a Sleuth los nombres de nuestras muestras:
```{r}
#| echo: true
sample_id <- dir(file.path("01_Raw_Data/kallisto_quant_output/"))
sample_id
```


## Resultados

También necesitamos obtener las rutas de los archivos a nuestros archivos de resultados.
```{r}
#| echo: true
kal_dirs <- file.path("01_Raw_Data/kallisto_quant_output/", sample_id)
```

## Nombre descriptivos

También necesitamos una tabla que proporcione nombres más significativos para describir nuestro experimento
```{r}
#| echo: true
s2c <- read.table(file.path("01_Raw_Data/kallisto_demo.tsv"),
                  header = TRUE,
                  stringsAsFactors = FALSE,
                  sep = "\t")
s2c
```

## Tabla
Añadiremos las rutas de nuestros archivos a la tabla.

```{r}
s2c <- dplyr::mutate(s2c, path = kal_dirs)
```
Veamos la tabla que hemos creado:
```{r}
s2c
```

## Tabla bonita

Veamos la tabla que hemos creado:
```{r}
library(DT)
DT::datatable(s2c)
```


## Step 3:Cargar nombres de genes desde Ensembl


A continuación, necesitamos determinar qué biomaRt utilizar. Esto puede ser un poco complejo, así que asegúrate de leer su [documentación](https://www.bioconductor.org/packages/devel/bioc/vignettes/biomaRt/inst/doc/biomaRt.html) Este [post](https://nsaunders.wordpress.com/2015/04/28/some-basics-of-biomart/)  de blog también es útil.

```{r}
#| echo: true
marts <- listMarts()
marts
```

## Step 3: Cargar nombres de genes desde Ensembl

Si no estás familiarizadx con  Ensembl,  consulta la documentación sobre cómo [usar BiomaRts diferentes a Ensembl](https://bioconductor.org/packages/release/bioc/vignettes/biomaRt/inst/doc/biomaRt.html#using-a-biomart-other-than-ensembl). Nosotros estamos usando plantas, así que...
```{r}
#| echo: true
marts <- listMarts(host = "plants.ensembl.org")
marts
```


## Step 3:Cargar nombres de genes desde Ensembl
Por ahora, recuerda que querremos usar `plants_mart`.

A continuación, necesitamos elegir un conjunto de datos específico.
```{r}
#| echo: true
plants_mart <- useMart("plants_mart", host = "plants.ensembl.org" )
listDatasets(plants_mart)
```

## Seleccionamos Arabidopsis thaliana

Después de buscar un poco, el conjunto de datos que necesitamos es `athaliana_eg_gene`. Finalmente, necesitamos actualizar nuestro `plants_mart` para ser más específico.

```{r}
#| echo: true
plants_mart <- useMart("plants_mart", dataset = "athaliana_eg_gene", host="plants.ensembl.org" )
```


Ahora queremos obtener atributos específicos de la lista de genes que podemos importar desde biomart.

```{r}
#| echo: true
datatable(listAttributes(plants_mart))
```

## Seleccionamos características

Podemos elegir cualquiera de estos. Por ejemplo  **transcript ids**, **gene ids**, **description**, y **gene names**

```{r}
#| echo: true
plants_mart <- useMart("plants_mart", dataset = "athaliana_eg_gene", host="plants.ensembl.org" )
t2g <- getBM(attributes = c("ensembl_transcript_id",
                            "ensembl_gene_id",
                            "description",
                            "external_gene_name"),
             mart = plants_mart)
t2g
```

## Importante

We need to make sure the `ensembl_transcript_id` column is named `target_id`

```{r}
#| echo: true
ttg <- dplyr::rename(t2g, target_id= ensembl_transcript_id, ens_gene = ensembl_gene_id, ext_gene = external_gene_name)
```


## Step 4: Prepare data for Sleuth

first we need to alter our experimental design so that we consider the full transcriptome sample to be the "control" to compare to...

```{r}
#| echo: true
s2c$genotype_variation_s <- as.factor(s2c$genotype_variation_s)
s2c$genotype_variation_s <- relevel(s2c$genotype_variation_s, ref = "wild type")

```

## Step 4: Preparar datos para Sleuth


Ahora necesitamos decirle a Sleuth tanto sobre los resultados de Kallisto como sobre los nombres de genes (y descripciones/metadata de genes) que obtuvimos de biomaRt. La función `sleuth_prep` hace esto.


```{r}
#| echo: true
# No corras esto si tu compu es muy lenta
#so <- sleuth_prep(s2c,
 #            full_model = ~genotype_variation_s,
  #           target_mapping = ttg,
   #          read_bootstrap_tpm=TRUE,
    #         extra_bootstrap_summary = TRUE)
#####
### saveRDS(so,file="03_Results/so.RDS")
## Mejor corre esta
readRDS(file="03_Results/so.RDS")
```



##Step 5: Exploración inicial de datos

### PCA

A continuación, deberíamos verificar si nuestras muestras (y réplicas) se agrupan en un PCA (como esperaríamos) o si hay valores atípicos. Cuando hacemos un gráfico por condición, esperaríamos que los colores similares se agrupen.

```{r}
#| echo: true
library(cowplot)
so<-readRDS(file="03_Results/so.RDS")
ggplot2::theme_set(theme_cowplot())
plot_pca(so, color_by = 'genotype_variation_s', text_labels = TRUE)
```
## Versión interactiva

```{r}
#| echo: true
ggplot2::theme_set(theme_cowplot())
g<-plot_pca(so, color_by = 'genotype_variation_s', text_labels = TRUE)
library(plotly)
ggplotly(g)
```


## Gráfica por tratamiento 



```{r}
#| echo: true
plot_pca(so, color_by = 'treatment_s', text_labels = TRUE)
```

## Genes

También podemos ver los genes involucrados en el primer componente principal (PC1) vemos los pesos (genes primarios cuyas combinaciones lineales definen los componentes principales).


```{r}
#| echo: true
plot_loadings(so, pc_input = 1)
```


## El gen "influencer"

Veamos cómo se ve este gen "influyente" (al menos según lo que nos dice el PCA) por condición.

```{r}
#| echo: true
plot_bootstrap(so, 'AT2G34420.1', color_by = 'genotype_variation_s')
```

## El gen "influencer"

Veamos cómo se ve este gen "influyente" (al menos según lo que nos dice el PCA) por tratamiento

```{r}
#| echo: true
plot_bootstrap(so, 'AT2G34420.1', color_by = 'treatment_s')
```


## Step 6: Modelado, pruebas y exploración de resultados



### Pruebas de expresión diferencial con Sleuth

Necesitamos correr funciones para probar la expresión diferencial (abundancias)

Primero crearemos un modelo.

```{r include=FALSE, error=TRUE}
#| echo: true
#No corras esto si tu máquina es muy lenta
#so2 <- sleuth_fit(so, ~genotype_variation_s, 'full')
#so2 <- sleuth_fit(so, ~1, 'reduced')
#so2 <- sleuth_lrt(so, 'reduced', 'full')
#saveRDS(so2,file="../03_Results/so2.RDS")
so2<-readRDS(file="03_Results/so2.RDS")
```


## Resultados



```{r}
#| echo: true
full_results <- sleuth_results(so2, 'reduced:full', 'lrt',
                               show_all = FALSE)
library(DT)
datatable(head(full_results))

```


## Prueba de Wald


```{r}
#| echo: true
wald_test <- colnames(design_matrix(so2))[2]
so <- sleuth_wt(so2, wald_test)
```


Shiny Browser

```{r}
sleuth_live(so)
```
